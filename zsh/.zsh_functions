prune_git_stale_branches() {
  # This function removes both stale remote-tracking references and their
  # corresponding local branches to keep your repository clean.

  # Usage
  # prune_git_stale_branches [remote]
  #   remote: The remote repository name (defaults to 'origin').

  # Example
  # prune_git_stale_branches
  # prune_git_stale_branches upstream

  local remote=${1:-origin}
  local stashed_changes=false
  local stashed_msg="You have stashed changes. Make sure to pop or drop them."

  typeset -i cleaned_branches=0
  typeset -r format="%(refname:short) %(upstream:track,nobracket)"
  typeset -r current_branch="$(git branch --show-current)"

  git remote prune $remote > /dev/null

  typeset -r default_branch=${(z)$(git remote show ${remote} | grep HEAD)[3]}

  while read -r local_branch remote_state; do
    [[ $remote_state != "gone" ]] && continue

    if [[ $local_branch == $current_branch ]]; then
      [[ -n $(git status --short) ]] && {
        git stash -u
        stashed_changes=true
      }
      git switch $default_branch
    fi

    git branch -D "$local_branch"
    cleaned_branches+=1
  done < <(git for-each-ref --format=${format} refs/heads) &> /dev/null

  if (( cleaned_branches == 0 )); then
    echo "Everything is up to date."
  elif [[ $stashed_changes == "true" ]]; then
    echo "Total pruned branches: $cleaned_branches\n${stashed_msg}"
  else
    echo "Total pruned branches: $cleaned_branches"
  fi

  return 0
}


prune_git_untracked_remotes() {
  # This function scans all remote‑tracking references and deletes any
  # remote/<branch> where there is no corresponding local branch <branch>.
  # It keeps your remote‑tracking list in sync with your local branches.

  # Usage
  # prune_git_untracked_remotes [remote]
  #   remote: The remote repository name (defaults to 'origin').

  # Example
  # prune_git_untracked_remotes
  # prune_git_untracked_remotes upstream

  local local_branches=($(git branch --list --format='%(refname:short)'))
  local remote=${1:-origin}
  local remote_base="${remote}/"
  local remote_wildcard="${remote_base}*"
  local remote_branches=()


  while read -r remote_reference; do

    if [[ -n ${local_branches[(r)${remote_reference#${remote_base}}]} ]]; then
      continue
    elif [[ $remote_reference == *"->"* ]]; then
      remote_reference="${remote_reference%% ->*}"
    fi

    remote_branches+=("${remote_reference}")

  done < <(git branch -rl "${remote_wildcard}")

  if (( ${#remote_branches} )); then
    git branch -r -d "${remote_branches[@]}" > /dev/null
    echo "Total pruned branches: ${#remote_branches[@]}"
  else
    echo "Everything is up to date."
  fi

  return 0
}
